package publicfaucet

import (
	"log/slog"
	"time"

	"go.mongodb.org/mongo-driver/mongo"

	"github.com/comiccoin-network/monorepo/cloud/comiccoin/internal/common/httperror"
	"github.com/comiccoin-network/monorepo/cloud/comiccoin/internal/common/kmutexutil"
	"github.com/comiccoin-network/monorepo/cloud/comiccoin/internal/common/security/password"
	sstring "github.com/comiccoin-network/monorepo/cloud/comiccoin/internal/common/security/securestring"
	"github.com/comiccoin-network/monorepo/cloud/comiccoin/config/constants"
	uc_federatedidentity "github.com/comiccoin-network/monorepo/cloud/comiccoin/internal/publicfaucet/usecase/federatedidentity"
)

type PublicFaucetResetPasswordService interface {
	Execute(sessCtx mongo.SessionContext, req *PublicFaucetResetPasswordRequestIDO) error
}

type publicfaucetResetPasswordServiceImpl struct {
	logger                           *slog.Logger
	kmutex                           kmutexutil.KMutexProvider
	passwordProvider                 password.Provider
	federatedidentityGetByVerificationCodeUseCase uc_federatedidentity.FederatedIdentityGetByVerificationCodeUseCase
	federatedidentityUpdateUseCase                uc_federatedidentity.FederatedIdentityUpdateUseCase
}

func NewPublicFaucetResetPasswordService(
	logger *slog.Logger,
	kmutex kmutexutil.KMutexProvider,
	pp password.Provider,
	uc1 uc_federatedidentity.FederatedIdentityGetByVerificationCodeUseCase,
	uc2 uc_federatedidentity.FederatedIdentityUpdateUseCase,
) PublicFaucetResetPasswordService {
	return &publicfaucetResetPasswordServiceImpl{logger, kmutex, pp, uc1, uc2}
}

type PublicFaucetResetPasswordRequestIDO struct {
	Code     string `json:"code"`
	Password string `json:"password"`
}

func (s *publicfaucetResetPasswordServiceImpl) Execute(sessCtx mongo.SessionContext, req *PublicFaucetResetPasswordRequestIDO) error {
	s.kmutex.Acquire(req.Code)
	defer func() {
		s.kmutex.Release(req.Code)
	}()

	// // Extract from our session the following data.
	// sessionID := sessCtx.Value(constants.SessionID).(string)

	// Lookup the federatedidentity in our database, else return a `400 Bad Request` error.
	u, err := s.federatedidentityGetByVerificationCodeUseCase.Execute(sessCtx, req.Code)
	if err != nil {
		s.logger.Error("database error", slog.Any("err", err))
		return err
	}
	if u == nil {
		s.logger.Warn("federatedidentity does not exist validation error")
		return httperror.NewForBadRequestWithSingleField("code", "does not exist")
	}

	//TODO: Handle expiry dates.

	securePassword, err := sstring.NewSecureString(req.Password)
	if err != nil {
		s.logger.Error("database error", slog.Any("err", err))
		return err
	}

	passwordHash, err := s.passwordProvider.GenerateHashFromPassword(securePassword)
	if err != nil {
		s.logger.Error("hashing error", slog.Any("error", err))
		return err
	}

	// Extract from our session the following data.
	ipAddress, _ := sessCtx.Value(constants.SessionIPAddress).(string)

	// Verify the federatedidentity.
	u.PasswordHash = passwordHash
	u.PasswordHashAlgorithm = s.passwordProvider.AlgorithmName()
	u.EmailVerificationCode = "" // Remove email active code so it cannot be used agian.
	u.EmailVerificationExpiry = time.Now()
	u.ModifiedAt = time.Now()
	// u.ModifiedByFederatedIdentityID = federatedidentityID
	// u.ModifiedByName = fmt.Sprintf("%s %s", u.FirstName, u.LastName)
	u.ModifiedFromIPAddress = ipAddress
	if err := s.federatedidentityUpdateUseCase.Execute(sessCtx, u); err != nil {
		s.logger.Error("update error", slog.Any("err", err))
		return err
	}

	return nil
}
