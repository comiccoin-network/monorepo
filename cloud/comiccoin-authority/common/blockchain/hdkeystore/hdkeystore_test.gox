package hdkeystore

import (
	"math/big"
	"testing"

	"github.com/ethereum/go-ethereum/common"
	"github.com/ethereum/go-ethereum/core/types"
	"github.com/stretchr/testify/assert"
)

const (
	testMnemonic   = "tag volcano eight thank tide danger coast health above argue embrace heavy"
	testPath       = "m/44'/60'/0'/0/0"
	testAddress    = "0xC49926C4124cEe1cbA0Ea94Ea31a6c12318df947"
	testPassphrase = "my secret passphrase"
)

func TestOpenWallet(t *testing.T) {
	tests := []struct {
		name       string
		mnemonic   string
		passphrase string
		path       string
		wantErr    bool
	}{
		{
			name:       "Valid mnemonic without passphrase",
			mnemonic:   testMnemonic,
			passphrase: "",
			path:       testPath,
			wantErr:    false,
		},
		{
			name:       "Valid mnemonic with passphrase",
			mnemonic:   testMnemonic,
			passphrase: testPassphrase,
			path:       testPath,
			wantErr:    false,
		},
		{
			name:       "Invalid mnemonic",
			mnemonic:   "invalid mnemonic phrase",
			passphrase: "",
			path:       testPath,
			wantErr:    true,
		},
		{
			name:       "Invalid derivation path",
			mnemonic:   testMnemonic,
			passphrase: "",
			path:       "m/invalid/path",
			wantErr:    true,
		},
	}

	adapter := NewAdapter()

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			address, wallet, err := adapter.OpenWallet(tt.mnemonic, tt.passphrase, tt.path)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, wallet)
				assert.Equal(t, common.Address{}, address)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, wallet)
				assert.NotEqual(t, common.Address{}, address)
			}
		})
	}
}

func TestSignTransaction(t *testing.T) {
	adapter := NewAdapter()
	address, wallet, err := adapter.OpenWallet(testMnemonic, "", testPath)
	assert.NoError(t, err)
	assert.NotNil(t, wallet)

	tests := []struct {
		name    string
		tx      *types.Transaction
		wantErr bool
	}{
		{
			name: "Valid transaction",
			tx: types.NewTransaction(
				0,                               // nonce
				common.HexToAddress("0x0"),      // to address
				big.NewInt(1000000000000000000), // value
				21000,                           // gas limit
				big.NewInt(21000000000),         // gas price
				[]byte{},                        // data
			),
			wantErr: false,
		},
		{
			name:    "Nil transaction",
			tx:      nil,
			wantErr: true,
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			signedTx, err := adapter.SignTransaction(wallet, testPath, tt.tx)

			if tt.wantErr {
				assert.Error(t, err)
				assert.Nil(t, signedTx)
			} else {
				assert.NoError(t, err)
				assert.NotNil(t, signedTx)

				// Verify the transaction is properly signed
				sender, err := types.Sender(types.NewEIP155Signer(big.NewInt(1)), signedTx)
				assert.NoError(t, err)
				assert.Equal(t, address, sender)
			}
		})
	}
}

func TestWithMultipleDerivationPaths(t *testing.T) {
	adapter := NewAdapter()
	paths := []string{
		"m/44'/60'/0'/0/0",
		"m/44'/60'/0'/0/1",
		"m/44'/60'/1'/0/0",
	}

	// Ensure different paths generate different addresses
	addresses := make(map[common.Address]bool)

	for _, path := range paths {
		address, wallet, err := adapter.OpenWallet(testMnemonic, "", path)
		assert.NoError(t, err)
		assert.NotNil(t, wallet)

		// Verify address is unique
		assert.False(t, addresses[address], "Address collision detected for path: %s", path)
		addresses[address] = true
	}
}
